import { useState as k, useCallback as Y, useRef as y, useEffect as D } from "../../external/preact/hooks/dist/hooks.module.js";
import P from "../../components/internal/Popover/utils/utils.js";
import { PopoverContainerPosition as t, PopoverContainerVariant as v } from "../../components/internal/Popover/types.js";
import { isRefObject as w } from "../../primitives/reactive/reflex/helpers.js";
import V from "../useReflex.js";
const W = [
  t.BOTTOM_RIGHT,
  t.BOTTOM_LEFT,
  t.TOP_RIGHT,
  t.TOP_LEFT
], q = 5, A = 4, U = 10, Z = ({
  position: M,
  variant: _,
  offset: O,
  additionalStyle: i,
  fixedPositioning: T,
  fullWidth: F,
  popover: a,
  targetElement: r
}) => {
  let n = 0, c = 0;
  const B = _ === v.TOOLTIP, l = a.clientHeight, C = a.clientWidth, g = a.firstChild, d = g.offsetHeight, E = g.offsetWidth, h = document.body.getBoundingClientRect(), e = r.getBoundingClientRect(), p = h.x + (h.width - E) / 2, u = e.x + (e.width - E) / 2, m = e.y + (e.height - d) / 2, b = window.scrollX, s = window.scrollY;
  switch (M) {
    case t.BOTTOM:
      n = F ? p : B ? u : e.x, c = e.y + e.height + O[1], T || (F || (n += b), c += s);
      break;
    case t.TOP:
      n = B ? u : e.x, c = e.y - (l + O[0]), T || (n += b, c += s - g.clientHeight + l);
      break;
    case t.RIGHT:
      n = e.x + e.width + O[2], c = B ? m : e.y - e.height / 2, T || (n += b, c += s);
      break;
    case t.LEFT:
      n = e.x - (C + O[3]), c = B ? m : e.y - e.height / 2, T || (n += b, c += s);
      break;
    case t.BOTTOM_LEFT:
      n = 5, c = e.y + e.height + O[1], T || (n += b, c += s);
      break;
    case t.BOTTOM_RIGHT:
      n = -5, c = e.y + e.height + O[1], T || (n = b - (h.width - e.right), c += s);
      break;
    case t.TOP_LEFT:
      n = q, c = e.y - l, T || (n += b, c += s - g.clientHeight + l);
      break;
    case t.TOP_RIGHT:
      n = -5, c = e.y - l, T || (n += b, c += s - g.clientHeight + l);
      break;
  }
  const R = {};
  if (i) {
    const G = !!i.maxY && c + (a == null ? void 0 : a.clientHeight) > i.maxY, o = !!i.minY && c < i.minY;
    if (G && i.maxY) {
      const I = e.y + e.height + 8, H = Math.max(0, i.maxY - I);
      H > 20 && (R.height = `${H}px`), R["overflow-y"] = "scroll";
    }
    if (o && i.minY && c) {
      const I = a.offsetHeight ?? a.clientHeight, H = Math.max(0, I - (i.minY - c));
      R.height = `${H}px`, H && (R["overflow-y"] = "scroll");
    }
    o && (c = i.minY ?? 0);
  }
  return {
    inset: M === t.TOP_RIGHT || M === t.BOTTOM_RIGHT ? "0 0 auto auto" : "0 auto auto 0",
    margin: "0",
    position: T ? "fixed" : "absolute",
    transform: `translate3d(${n}px, ${c}px, 0)`,
    visibility: "hidden",
    ...R
  };
}, tt = (M, _, O, i, T, F, a, r, n, c, B, l) => {
  const [C, g] = k(!0), [d, E] = k(r ? !r : !!i), [h, e] = k(i || t.TOP), [p, u] = k([]), m = Y(
    (s) => {
      var G;
      const R = document.documentElement.clientWidth, L = (G = _.current) == null ? void 0 : G.getBoundingClientRect();
      if (s.intersectionRatio === 1) return E(!0);
      if (!C && s.intersectionRatio !== 1) {
        if (p && p.length === (r ? 8 : 4)) {
          const o = p.reduce((I, H) => H[1] > I[1] ? H : I, p[0]);
          return e(o[0]), E(!0);
        }
        switch (E(!1), h) {
          case t.TOP:
            u((o) => [...o, [t.TOP, s.intersectionRatio]]), e(t.BOTTOM);
            break;
          case t.BOTTOM:
            u((o) => [...o, [t.BOTTOM, s.intersectionRatio]]), e(
              r ? ((L == null ? void 0 : L.x) || 0) > R / 2 ? t.BOTTOM_RIGHT : t.BOTTOM_LEFT : t.RIGHT
            );
            break;
          case t.BOTTOM_LEFT:
            u((o) => [...o, [t.BOTTOM_LEFT, s.intersectionRatio]]), e(r ? t.TOP_LEFT : t.RIGHT);
            break;
          case t.BOTTOM_RIGHT:
            u((o) => [...o, [t.BOTTOM_RIGHT, s.intersectionRatio]]), e(r ? t.TOP_RIGHT : t.RIGHT);
            break;
          case t.TOP_LEFT:
            u((o) => [...o, [t.TOP_LEFT, s.intersectionRatio]]), e(r ? t.BOTTOM_LEFT : t.RIGHT);
            break;
          case t.TOP_RIGHT:
            u((o) => [...o, [t.TOP_RIGHT, s.intersectionRatio]]), e(r ? t.BOTTOM_RIGHT : t.RIGHT);
            break;
          case t.RIGHT:
            u((o) => [...o, [t.RIGHT, s.intersectionRatio]]), e(t.LEFT);
            break;
          case t.LEFT:
            u((o) => [...o, [t.LEFT, s.intersectionRatio]]), e(t.TOP);
            break;
        }
      }
    },
    [_, C, p, r, h]
  ), b = y(m);
  return D(() => {
    P(b.current).remove(), b.current = m;
  }, [m]), V(
    Y(
      (s, R) => {
        var L, G, o;
        if (R && (!i || r) && P(m).observer.unobserve(R), s && _.current) {
          if ((!i || r) && P(m).observer.observe(s), !(s instanceof Element)) return;
          const H = {
            ...Z({
              variant: O,
              offset: M,
              additionalStyle: c,
              fixedPositioning: n,
              fullWidth: a,
              popover: s,
              position: h,
              targetElement: _.current
            }),
            ...d && { visibility: "visible" },
            ...F && {
              "min-width": "fit-content",
              width: `${_.current.clientWidth}px`
            }
          };
          if (s.setAttribute(
            "style",
            Object.entries(H).map((f) => f.join(":")).join(";")
          ), C && g(!1), O && O === v.TOOLTIP && T && w(T) && ((L = T.current) == null || L.setAttribute("data-popover-placement", h), W.includes(h))) {
            const f = _.current.getBoundingClientRect(), x = s.firstChild, $ = x.offsetWidth, N = f.x + (f.width - $) / 2, X = x.offsetHeight, j = h === t.BOTTOM_RIGHT || h === t.BOTTOM_LEFT ? X + A : A;
            (G = T.current) == null || G.setAttribute(
              "style",
              `transform: translate3d(${N}px, -${j}px, 0) rotate(45deg); inset: 0 0 auto auto`
            );
          }
          if (O && O === v.TOOLTIP && l && w(l) && W.includes(h)) {
            const f = document.documentElement.clientWidth;
            (o = l.current) == null || o.setAttribute("style", `max-width: ${f - U}px`);
          }
        }
      },
      [
        i,
        r,
        _,
        m,
        O,
        M,
        c,
        n,
        a,
        h,
        d,
        F,
        C,
        T,
        l
      ]
    ),
    B
  );
};
export {
  tt as default
};
