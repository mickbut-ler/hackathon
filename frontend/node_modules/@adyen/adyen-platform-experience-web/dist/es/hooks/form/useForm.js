import { useRef as O, useCallback as y } from "../../external/preact/hooks/dist/hooks.module.js";
function k(s, o) {
  const u = o.split(".");
  let i = s;
  for (const t of u) {
    if (i == null) return;
    i = i[t];
  }
  return i;
}
function R(s, o, u) {
  if (!o)
    return;
  const i = o.split("."), t = i.pop();
  let n = s;
  for (let d = 0; d < i.length; d++) {
    const _ = i[d];
    if (typeof n[_] != "object" || n[_] === null) {
      const g = i[d + 1];
      n[_] = g !== void 0 && /^\d+$/.test(g) ? [] : {};
    }
    n = n[_];
  }
  n[t] = u;
}
function E(s) {
  if (s == null || typeof s != "object") return s;
  if (Array.isArray(s)) return s.filter((u) => u !== "" && u !== null);
  const o = {};
  for (const [u, i] of Object.entries(s))
    if (!(i === "" || i === null || i === void 0))
      if (typeof i == "object" && !Array.isArray(i)) {
        const t = E(i);
        Object.keys(t).length > 0 && (o[u] = t);
      } else
        o[u] = i;
  return o;
}
function V(s, o = "") {
  const u = {};
  for (const i in s)
    if (Object.prototype.hasOwnProperty.call(s, i)) {
      const t = s[i], n = o ? `${o}.${i}` : i;
      t && typeof t == "object" && !Array.isArray(t) && !(t instanceof Date) && !(t instanceof File) && !(t instanceof FileList) ? Object.assign(u, V(t, n)) : u[n] = t;
    }
  return u;
}
async function q(s, o, u) {
  if (o) {
    if (o.required && (s == null || s === "" || Array.isArray(s) && s.length === 0))
      return { type: "required", message: typeof o.required == "string" ? o.required : u.get("common.errors.fieldRequired") };
    if (o.validate)
      try {
        const i = await o.validate(s);
        if (!i.valid)
          return { message: i.message, type: "validation" };
      } catch (i) {
        return console.error("A custom validation function threw an error:", i), { type: "validation", message: "Validation error occurred" };
      }
  }
}
function j(s) {
  const { defaultValues: o = {}, i18n: u } = s, i = O();
  if (!i.current) {
    const e = {
      _values: /* @__PURE__ */ new Map(),
      _errors: /* @__PURE__ */ new Map(),
      _touched: /* @__PURE__ */ new Map(),
      _dirty: /* @__PURE__ */ new Map(),
      _subscribers: /* @__PURE__ */ new Set(),
      _validationCounters: /* @__PURE__ */ new Map(),
      _fieldRules: /* @__PURE__ */ new Map(),
      _options: s,
      _defaultValues: o,
      _isSubmitting: !1,
      _computedErrors: {},
      _computedTouchedFields: {},
      _computedDirtyFields: {},
      subscribe: (r) => (e._subscribers.add(r), () => e._subscribers.delete(r)),
      notify: () => {
        e._subscribers.forEach((r) => r());
      },
      setValue: (r, l, c) => {
        const v = k(e._defaultValues, r), b = l !== v;
        e._values.set(r, l), (c == null ? void 0 : c.shouldDirty) !== !1 && (e._dirty.set(r, b), b ? e._computedDirtyFields[r] = !0 : delete e._computedDirtyFields[r]), c != null && c.shouldTouch && (e._touched.set(r, !0), e._computedTouchedFields[r] = !0);
        const a = e._options.mode || "onBlur";
        (c == null ? void 0 : c.shouldValidate) !== !1 && (a === "onInput" || a === "all" || c != null && c.shouldValidate) && F({ control: e, name: r, value: l, rules: e._fieldRules.get(r), i18n: u }), e.notify();
      },
      setTouched: (r, l) => {
        e._touched.set(r, l), l ? e._computedTouchedFields[r] = !0 : delete e._computedTouchedFields[r], e.notify();
      },
      getValue: (r) => e._values.get(r),
      getFieldState: (r) => ({
        error: e._errors.get(r),
        isTouched: e._touched.get(r) || !1,
        isDirty: e._dirty.get(r) || !1
      }),
      getFormState: () => {
        const l = !(Object.keys(e._computedErrors).length > 0) && !e._isSubmitting;
        return {
          dirtyFields: e._computedDirtyFields,
          touchedFields: e._computedTouchedFields,
          isSubmitting: e._isSubmitting,
          isValid: l,
          errors: e._computedErrors
        };
      },
      register: (r, l) => (e._fieldRules.set(r, l), () => {
        e._fieldRules.delete(r), e._validationCounters.delete(r);
      }),
      trigger: async (r) => {
        const l = r ? Array.isArray(r) ? r : [r] : Array.from(e._values.keys());
        let c = !1;
        l.forEach((a) => {
          e._touched.has(a) || (e._touched.set(a, !0), e._computedTouchedFields[a] = !0, c = !0);
        }), c && e.notify();
        const v = l.map(async (a) => {
          const C = e._values.get(a), m = e._fieldRules.get(a);
          return m && await F({ control: e, name: a, value: C, rules: m, i18n: u }), !e._errors.has(a);
        });
        return (await Promise.all(v)).every((a) => a);
      }
    }, f = V(o);
    Object.entries(f).forEach(([r, l]) => {
      e._values.set(r, l);
    }), i.current = e;
  }
  const t = i.current, n = t._computedErrors, d = t._computedDirtyFields, _ = t._computedTouchedFields, w = !(Object.keys(n).length > 0) && !t._isSubmitting, S = {
    dirtyFields: d,
    touchedFields: _,
    isSubmitting: t._isSubmitting,
    isValid: w,
    errors: n
  }, T = y(
    (e, f, r) => {
      t.setValue(e, f, r);
    },
    [t]
  ), h = y(
    (e) => {
      if (e)
        return t._values.get(e);
      const f = {};
      return t._values.forEach((r, l) => {
        R(f, l, r);
      }), f;
    },
    [t]
  ), A = y(
    (e) => {
      const f = e || t._defaultValues;
      e && (t._defaultValues = e), t._values.clear(), t._errors.clear(), t._touched.clear(), t._dirty.clear(), t._validationCounters.clear(), t._computedErrors = {}, t._computedTouchedFields = {}, t._computedDirtyFields = {};
      const r = V(f);
      Object.entries(r).forEach(([l, c]) => {
        t._values.set(l, c);
      }), t._isSubmitting = !1, t.notify();
    },
    [t]
  ), p = y(
    async (e) => t.trigger(e),
    [t]
  ), D = y(
    (e, f) => async (r) => {
      r && r.preventDefault && r.preventDefault(), t._isSubmitting = !0, t.notify();
      try {
        if (await p()) {
          const c = E(h());
          await e(c);
        } else f && f(t._computedErrors);
      } finally {
        t._isSubmitting = !1, t.notify();
      }
    },
    [t, p, h]
  );
  return {
    control: t,
    handleSubmit: D,
    setValue: T,
    getValues: h,
    reset: A,
    formState: S,
    trigger: p
  };
}
async function F({
  control: s,
  i18n: o,
  name: u,
  value: i,
  rules: t
}) {
  const n = (s._validationCounters.get(u) || 0) + 1;
  s._validationCounters.set(u, n);
  try {
    const d = await q(i, t, o);
    s._validationCounters.get(u) === n && (d ? (s._errors.set(u, d), s._computedErrors[u] = d) : (s._errors.delete(u), delete s._computedErrors[u]), s.notify());
  } catch {
    if (s._validationCounters.get(u) === n) {
      const _ = { type: "validation", message: "Validation error" };
      s._errors.set(u, _), s._computedErrors[u] = _, s.notify();
    }
  }
}
export {
  k as getNestedValue,
  R as setNestedValue,
  j as useForm,
  F as validateFieldWithRaceConditionHandling
};
