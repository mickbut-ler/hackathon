import { useReducer as x, useMemo as Y, useCallback as l } from "../../../external/preact/hooks/dist/hooks.module.js";
import { useForm as K, getNestedValue as R } from "../useForm.js";
function k(a, p) {
  switch (p.type) {
    case "SET_STEP":
      return {
        ...a,
        currentStep: p.payload.step,
        visitedSteps: /* @__PURE__ */ new Set([...a.visitedSteps, p.payload.step])
      };
    case "NEXT_STEP": {
      const r = a.currentStep + 1;
      return {
        ...a,
        currentStep: r,
        visitedSteps: /* @__PURE__ */ new Set([...a.visitedSteps, r]),
        completedSteps: /* @__PURE__ */ new Set([...a.completedSteps, a.currentStep])
      };
    }
    case "PREVIOUS_STEP":
      return {
        ...a,
        currentStep: Math.max(0, a.currentStep - 1)
      };
    case "MARK_STEP_COMPLETED":
      return {
        ...a,
        completedSteps: /* @__PURE__ */ new Set([...a.completedSteps, p.payload.step])
      };
    case "MARK_STEP_VISITED":
      return {
        ...a,
        visitedSteps: /* @__PURE__ */ new Set([...a.visitedSteps, p.payload.step])
      };
    case "SET_STEP_VALIDATION": {
      const r = new Map(a.stepValidation);
      return r.set(p.payload.step, p.payload.isValid), {
        ...a,
        stepValidation: r
      };
    }
    case "SET_TRANSITIONING":
      return {
        ...a,
        isTransitioning: p.payload
      };
    case "RESET_WIZARD":
      return {
        currentStep: 0,
        completedSteps: /* @__PURE__ */ new Set(),
        visitedSteps: /* @__PURE__ */ new Set([0]),
        stepValidation: /* @__PURE__ */ new Map(),
        isTransitioning: !1,
        displayValues: /* @__PURE__ */ new Map()
      };
    case "SET_DISPLAY_VALUE": {
      const r = new Map(a.displayValues), { field: c, displayValue: T } = p.payload;
      return T === void 0 ? r.delete(c) : r.set(c, T), { ...a, displayValues: r };
    }
    case "RESET_DISPLAY_VALUES":
      return { ...a, displayValues: /* @__PURE__ */ new Map() };
    default:
      return a;
  }
}
function Z(a) {
  const { i18n: p, steps: r, defaultValues: c, mode: T = "onBlur", onStepChange: o, validateBeforeNext: y = !0 } = a, [t, i] = x(k, {
    currentStep: 0,
    completedSteps: /* @__PURE__ */ new Set(),
    visitedSteps: /* @__PURE__ */ new Set([0]),
    stepValidation: /* @__PURE__ */ new Map(),
    isTransitioning: !1,
    displayValues: /* @__PURE__ */ new Map()
  }), v = K({
    defaultValues: c,
    i18n: p,
    mode: T
  }), { trigger: m, getValues: d } = v, E = r.length, g = r[t.currentStep], w = t.currentStep === 0, A = t.currentStep === E - 1, V = !w && !t.isTransitioning, N = !A && !t.isTransitioning, P = Y(() => r.flatMap((e) => e.fields).reduce(
    (e, s) => ({ ...e, [s.fieldName]: s }),
    {}
  ), [r]), I = l(
    async (e) => {
      const s = r[e];
      if (!s) return !1;
      if (s.isOptional) {
        const n = d();
        if (!s.fields.some(({ fieldName: b }) => {
          const _ = R(n, b);
          return _ !== void 0 && _ !== "" && _ !== null;
        })) return !0;
      }
      const u = s.fields.filter(({ visible: n }) => n).map(({ fieldName: n }) => n), S = await m(u);
      if (S && s.validate) {
        const n = d();
        return await s.validate(n);
      }
      return S;
    },
    [r, d, m]
  ), f = l(async () => {
    const e = await I(t.currentStep);
    return i({
      type: "SET_STEP_VALIDATION",
      payload: { step: t.currentStep, isValid: e }
    }), e;
  }, [t.currentStep, I]), O = l(
    (e) => t.stepValidation.get(e) ?? !1,
    [t.stepValidation]
  ), D = l(
    (e) => t.completedSteps.has(e),
    [t.completedSteps]
  ), M = l(
    async (e, s) => {
      if (e < 0 || e >= E)
        throw new Error(`Invalid step index: ${e}`);
      if (!(s != null && s.skipValidation) && y && e > t.currentStep) {
        i({ type: "SET_TRANSITIONING", payload: !0 });
        try {
          if (!await f())
            return i({ type: "SET_TRANSITIONING", payload: !1 }), !1;
          i({ type: "MARK_STEP_COMPLETED", payload: { step: t.currentStep } });
        } catch (S) {
          return i({ type: "SET_TRANSITIONING", payload: !1 }), console.error("Wizard step validation failed:", S), !1;
        }
      }
      const u = t.currentStep;
      return i({ type: "SET_STEP", payload: { step: e } }), i({ type: "SET_TRANSITIONING", payload: !1 }), o && o(e, u), !0;
    },
    [E, y, t.currentStep, f, o]
  ), h = l(async () => {
    if (!N) return !1;
    if (i({ type: "SET_TRANSITIONING", payload: !0 }), y)
      try {
        if (!await f())
          return i({ type: "SET_TRANSITIONING", payload: !1 }), !1;
      } catch (s) {
        return console.error("Wizard step validation failed on nextStep:", s), i({ type: "SET_TRANSITIONING", payload: !1 }), !1;
      }
    const e = t.currentStep;
    return i({ type: "NEXT_STEP" }), i({ type: "SET_TRANSITIONING", payload: !1 }), o && o(e + 1, e), !0;
  }, [N, y, f, t.currentStep, o]), L = l(() => {
    if (!V) return;
    const e = t.currentStep;
    i({ type: "PREVIOUS_STEP" }), o && o(e - 1, e);
  }, [V, t.currentStep, o]), G = l(() => {
    i({ type: "RESET_WIZARD" });
  }, []), C = l((e, s) => {
    i({ type: "SET_DISPLAY_VALUE", payload: { field: e, displayValue: s } });
  }, []), F = l(() => {
    i({ type: "RESET_DISPLAY_VALUES" });
  }, []), z = l(() => {
    const e = d(), s = {};
    return r.forEach((u) => {
      const S = u.fields.filter((n) => n.visible !== !1).map((n) => ({
        label: n.label,
        value: R(e, n.fieldName),
        id: n.fieldName,
        displayValue: t.displayValues.get(n.fieldName)
      })).filter((n) => n.value !== void 0 && n.value !== null && n.value !== "");
      S.length > 0 && (s[u.id] = {
        title: u.title,
        fields: S
      });
    }), s;
  }, [r, d, t.displayValues]), U = l(
    (e) => t.displayValues.get(e),
    [t.displayValues]
  );
  return {
    ...v,
    // Wizard state
    currentStep: t.currentStep,
    currentStepConfig: g,
    isFirstStep: w,
    isLastStep: A,
    canGoNext: N,
    canGoPrevious: V,
    fieldsConfig: P,
    // Navigation methods
    goToStep: M,
    nextStep: h,
    previousStep: L,
    resetWizard: G,
    // Validation methods
    validateStep: I,
    isStepValid: O,
    isStepComplete: D,
    // Summary data
    getSummaryData: z,
    // Display values
    getDisplayValue: U,
    setFieldDisplayValue: C,
    resetFieldDisplayValues: F
  };
}
export {
  Z as useWizardForm
};
