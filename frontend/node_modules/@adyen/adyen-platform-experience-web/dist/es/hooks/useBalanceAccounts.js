import { useState as C, useMemo as c, useCallback as g, useEffect as k } from "../external/preact/hooks/dist/hooks.module.js";
import { useFetch as y } from "./useFetch.js";
import { useConfigContext as E } from "../core/ConfigContext/context.js";
import { isFunction as M } from "../utils/value/is.js";
import { EMPTY_OBJECT as T } from "../utils/value/constants.js";
const m = /* @__PURE__ */ new WeakMap(), P = (o, f) => {
  const { getBalanceAccounts: e } = E().endpoints, [i, a] = C(() => e && m.get(e)), h = c(
    () => !i && M(e) && f !== !1,
    [i, f, e]
  ), { data: t, isFetching: p, error: u } = y({
    queryFn: g(async () => e == null ? void 0 : e(T), [e]),
    fetchOptions: { enabled: h, keepPrevData: !0 }
  }), s = i ?? (t == null ? void 0 : t.data), r = c(
    () => s == null ? void 0 : s.filter((n) => !o || o === n.id),
    [s, o]
  ), F = c(
    () => !!o && !!(s != null && s.length) && (r == null ? void 0 : r.length) === 0,
    [s, o, r]
  );
  return k(() => {
    if (t != null && t.data && e) {
      const n = t.data;
      m.set(e, n), a(n);
    }
  }, [t, e]), { balanceAccounts: r, isBalanceAccountIdWrong: F, isFetching: p, error: u };
};
export {
  P as default
};
