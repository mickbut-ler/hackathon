import { useRef as B, useCallback as A, useMemo as C } from "../external/preact/hooks/dist/hooks.module.js";
import { useFetch as F } from "./useFetch.js";
import { createAbortable as k } from "../primitives/async/abortable/main.js";
import { useConfigContext as O } from "../core/ConfigContext/context.js";
import { isFunction as w } from "../utils/value/is.js";
import { EMPTY_ARRAY as E } from "../utils/value/constants.js";
const z = ({ balanceAccount: a }) => {
  const { getBalances: n } = O().endpoints, f = B(k()).current, s = a == null ? void 0 : a.id, o = w(n), i = o && !!s, p = A(async () => {
    if (i) {
      const { signal: e } = f.refresh(!0);
      try {
        const t = await n({ signal: e }, { path: { balanceAccountId: s } });
        if (!e.aborted) return t == null ? void 0 : t.data;
      } catch (c) {
        if (!e.aborted) throw c;
      }
    }
  }, [f, s, i, n]), { data: u, error: m, isFetching: b } = F({
    fetchOptions: { enabled: i },
    queryFn: p
  }), { balances: h, balancesLookup: y, currencies: l } = C(() => {
    const e = [...Array.isArray(u) ? u : E], c = [...e].sort(({ currency: r }, { currency: g }) => r.localeCompare(g)), t = Object.freeze(Object.fromEntries(e.map((r) => [r.currency, r]))), d = Object.freeze([...new Set(c.map(({ currency: r }) => r))]);
    return { balances: e, balancesLookup: t, currencies: d };
  }, [u]);
  return {
    balances: h,
    balancesLookup: y,
    currencies: l,
    error: m,
    isAvailable: o,
    isEmpty: !!m || !l.length,
    isMultiCurrency: l.length > 1,
    isWaiting: b || o && !s
  };
};
export {
  z as default
};
