import { some as c } from "../../../utils/collection/main.js";
import { isUndefined as p, isNullish as E, isNumber as R } from "../../../utils/value/is.js";
import { mod as N } from "../../../utils/value/number.js";
const d = `:scope ${`
    a[href],
    audio[controls],
    video[controls],
    button,
    input,
    select,
    textarea,
    [contenteditable],
    [tabindex]
`.replace(/\s+/, "")}`, S = ["contenteditable", "controls", "disabled", "hidden", "href", "inert", "tabindex"], h = /* @__PURE__ */ new Map(), g = (t) => t.tagName === "INPUT", b = (t) => g(t) && t.type === "radio", x = (t) => {
  const e = t.name, r = t.form, n = h.get(r);
  let s = n == null ? void 0 : n.get(e);
  return p(s) && r && (s = r.querySelector(`:scope input[type=radio][name='${e}']:checked`) || null, h.set(r, (n || /* @__PURE__ */ new Map()).set(e, s))), s === t;
}, A = (t, e) => {
  let r = !1;
  for (const n of e)
    if (n.type === "attributes" ? r || (r = n.target instanceof Element && // Target is a tabbable element (possibly due to attribute changes)
    // For example, disabled set to false, tabindex set to a number, etc.
    (u(n.target) || // Target is already contained in the list of tabbables
    // Attribute changes could make it no longer tabbable (e.g. disabled set to true)
    t.includes(n.target))) : (r || (r = // At least one tabbable node was added to the DOM tree of the root element
    c(
      n.addedNodes,
      (s) => s instanceof Element && // Added node is a tabbable element
      (u(s) || // At least one descendant of added node is a tabbable element
      c(s.querySelectorAll(d), u))
    )), r || (r = // At least one tabbable node was removed from the DOM tree of the root element
    // That is, removed from the list of tabbables for the root element
    c(
      n.removedNodes,
      (s) => s instanceof Element && // Removed node is a tabbable element
      (t.includes(s) || // At least one descendant of removed node is a tabbable element
      c(s.querySelectorAll(d), (i) => t.includes(i)))
    ))), r) break;
  return r;
}, v = (t = document.body, e) => {
  if (p(t)) return !1;
  if (E(e)) return !!document.activeElement && v(t, document.activeElement);
  let r = e == null ? void 0 : e.parentNode;
  for (; r; ) {
    if (r === t) return !0;
    r = r == null ? void 0 : r.parentNode;
  }
  return !1;
}, I = (t) => !// [TODO]: Include all of these checks
// (1) matches focusable elements selector
// (2) is disabled element
// (3) is inert or inert subtree child
// (4) is hidden input
// (5) with visibility: hidden
// (6) is summary of open details element
// (7) is details with summary element
// (8) is disabled fieldset subtree child
/* (1) */
(!t.matches(d) || /* (2) */
t != null && t.disabled || /* (3) */
/^(true)?$/.test(t.getAttribute("inert")) || /* (4) */
g(t) && t.hidden), u = (t) => !(b(t) && !x(t) || // (1) is not checked radio button
(t == null ? void 0 : t.tabIndex) < 0 || // (2) has negative tabindex
!I(t)), M = () => {
  const t = new MutationObserver((o) => A(e, o) && i()), e = [];
  let r = -1, n = null;
  const s = (o) => {
    var f;
    if (o < 0) return;
    const l = Math.min(o, e.length - 1);
    r !== l && (r = l), (f = e[r]) == null || f.focus();
  }, i = () => {
    e.length = 0, n instanceof Element && (n.querySelectorAll(d).forEach((o) => u(o) && e.push(o)), v(n) && (a.current = document.activeElement));
  }, a = Object.create(null, {
    current: {
      get: () => e[r] ?? null,
      set: (o) => {
        if (o) {
          if (!R(o)) return s(e.indexOf(o));
          if (o === ~~o)
            return s(N(r + o, e.length));
        }
      }
    },
    root: {
      get: () => n,
      set: (o) => {
        o !== n && (n && t.disconnect(), n = o instanceof Element ? o : null, e.length = 0, n && (t.observe(n, {
          attributeFilter: S,
          attributes: !0,
          childList: !0,
          subtree: !0
        }), i()));
      }
    },
    tabbables: { value: e }
  });
  return a;
};
export {
  d as SELECTORS,
  M as default,
  v as focusIsWithin,
  I as isFocusable,
  u as isTabbable,
  M as withTabbableRoot
};
