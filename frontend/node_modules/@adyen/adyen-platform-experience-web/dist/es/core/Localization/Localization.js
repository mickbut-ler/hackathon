var $ = Object.defineProperty;
var v = (s) => {
  throw TypeError(s);
};
var I = (s, t, r) => t in s ? $(s, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : s[t] = r;
var R = (s, t, r) => I(s, typeof t != "symbol" ? t + "" : t, r), b = (s, t, r) => t.has(s) || v("Cannot " + r);
var e = (s, t, r) => (b(s, t, "read from private field"), r ? r.call(s) : t.get(s)), n = (s, t, r) => t.has(s) ? v("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(s) : t.set(s, r), h = (s, t, r, i) => (b(s, t, "write to private field"), i ? i.call(s, r) : t.set(s, r), r), z = (s, t, r) => (b(s, t, "access private method"), r);
import { FALLBACK_LOCALE as S, DEFAULT_TRANSLATIONS as M, getLocalesFromTranslationSourcesRecord as W, DEFAULT_DATETIME_FORMAT as q, SUPPORTED_LOCALES as B } from "./constants/localization.js";
import { en_US as x } from "../../translations/index.js";
import { getLocalisedAmount as G } from "./amount/amount-util.js";
import { createTranslationsLoader as V, getLocalizationProxyDescriptors as Y } from "./localization-utils.js";
import { toTwoLetterCode as N, formatCustomTranslations as Z, getTranslation as F } from "./utils.js";
import { httpGet as j } from "../Http/http.js";
import P from "../../config/translations/swapConfig.json.js";
import { createWatchlist as H } from "../../primitives/reactive/watchlist/main.js";
import J from "./datetime/restamper/restamper.js";
import { isNullish as k, isUndefined as Q, isNull as K } from "../../utils/value/is.js";
import { ALREADY_RESOLVED_PROMISE as X } from "../../utils/async/constants.js";
import { struct as tt } from "../../utils/struct/main.js";
import { noop as et } from "../../utils/common.js";
var l, w, g, y, u, m, c, C, D, f, p, L, T, A, O, E, _;
class gt {
  constructor(t = S, r, i = "", o = "") {
    n(this, E);
    n(this, l, S);
    n(this, w, N(e(this, l)));
    n(this, g, [S]);
    n(this, y, e(this, g));
    n(this, u);
    n(this, m, M);
    n(this, c, V.call(this));
    n(this, C);
    n(this, D, X);
    n(this, f);
    n(this, p);
    n(this, L, H({ timestamp: () => performance.now() }));
    n(this, T, J());
    n(this, A, P);
    n(this, O, /* @__PURE__ */ new Set());
    R(this, "watch", e(this, L).subscribe.bind(void 0));
    R(this, "i18n", tt(Y.call(this)));
    R(this, "preferredTranslations");
    this.watch(et), h(this, C, (a) => j({
      loadingContext: i,
      path: `/${a}.json`,
      versionless: !0,
      skipContentType: !0,
      errorLevel: "info"
    })), this.preferredTranslations = Object.freeze(
      (r == null ? void 0 : r.reduce((a, d) => ({ ...a, ...d }), x)) ?? { ...x }
    ), h(this, g, W(this.preferredTranslations)), this.locale = t, (async () => {
      if (!o)
        return P;
      try {
        return await j({
          loadingContext: o,
          path: "/translations/swapConfig.json",
          versionless: !0,
          skipContentType: !0,
          errorLevel: "error"
        });
      } catch (a) {
        return console.warn("Failed to load swapConfig from CDN, using local fallback", a), P;
      }
    })().then((a) => h(this, A, a));
  }
  get customTranslations() {
    return e(this, u) ?? {};
  }
  set customTranslations(t) {
    let r, i = [...e(this, g)];
    if (!k(t)) {
      r = Z(t, B);
      const o = Object.keys(r);
      i = [...i, ...o].sort().filter((a, d, U) => U.indexOf(a) === d);
    }
    e(this, c).supportedLocales = i, z(this, E, _).call(this, r);
  }
  get languageCode() {
    return e(this, w);
  }
  get lastRefreshTimestamp() {
    return e(this, L).snapshot.timestamp;
  }
  get locale() {
    return e(this, l);
  }
  set locale(t) {
    if (k(t))
      this.locale = S;
    else {
      if (e(this, c).locale = t, e(this, l) === e(this, c).locale) return;
      z(this, E, _).call(this, e(this, u));
    }
  }
  get ready() {
    return e(this, D);
  }
  get supportedLocales() {
    return e(this, y);
  }
  get timezone() {
    return e(this, T).tz.current;
  }
  set timezone(t) {
    e(this, T).tz = t;
  }
  /**
   * Returns a translated string from a key in the current {@link Localization.locale}
   * @param key - Translation key
   * @param options - Translation options
   * @returns Translated string
   */
  get(t, r) {
    if (e(this, u)) {
      const o = e(this, A)[t];
      if (o && typeof o == "string" && o !== t) {
        const a = F(e(this, m), o, r);
        if (!K(a))
          return e(this, O).has(o) || (console.warn(
            `[Adyen Platform Experience Web] Deprecated translation key detected: "${o}". Please update to use the new key: "${t}". This backward compatibility will be removed in a future version.`
          ), e(this, O).add(o)), a;
      }
    }
    const i = F(e(this, m), t, r);
    return K(i) ? t : i;
  }
  /**
   * Returns a boolean that checks if the translation key exists in the current {@link Localization.locale}
   * @param key - Translation key
   * @param options - Translation options
   * @returns boolean
   */
  has(t, r) {
    return !!F(e(this, m), t, r);
  }
  /**
   * Returns a localized string for an amount
   * @param amount - Amount to be converted
   * @param currencyCode - Currency code of the amount
   * @param options - Options for String.prototype.toLocaleString
   */
  amount(t, r, i) {
    const { hideCurrency: o, ...a } = i || {}, d = G(t, e(this, l), r, o, {
      ...a,
      currencyDisplay: "symbol",
      signDisplay: "never"
    });
    return t < 0 ? `- ${d}` : d;
  }
  /**
   * Returns a localized string for a date
   * @param date - Date to be localized
   * @param options - Options for {@link Date.toLocaleDateString}
   */
  date(t, r = {}) {
    const i = { ...q, timeZone: e(this, T).tz.current, ...r };
    return new Date(t).toLocaleDateString(e(this, l), i);
  }
  /**
   * Returns a localized string for a full date
   * @param date - Date to be localized
   */
  fullDate(t) {
    return this.date(t, {
      month: "short",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: !1
    });
  }
}
l = new WeakMap(), w = new WeakMap(), g = new WeakMap(), y = new WeakMap(), u = new WeakMap(), m = new WeakMap(), c = new WeakMap(), C = new WeakMap(), D = new WeakMap(), f = new WeakMap(), p = new WeakMap(), L = new WeakMap(), T = new WeakMap(), A = new WeakMap(), O = new WeakMap(), E = new WeakSet(), _ = function(t) {
  Q(e(this, p)) && h(this, D, new Promise((o) => {
    h(this, p, () => {
      o(e(this, f)), h(this, f, h(this, p, void 0));
    });
  }));
  const r = () => {
    var o;
    e(this, f) === i && ((o = e(this, p)) == null || o.call(this));
  }, i = h(this, f, (async () => {
    h(this, m, await e(this, c).load(e(this, C), t)), h(this, l, e(this, c).locale), h(this, y, Object.freeze(e(this, c).supportedLocales)), h(this, u, t), h(this, w, N(e(this, l))), e(this, L).requestNotification();
  })());
  i.then(r).catch((o) => {
    r(), console.error(o);
  });
};
export {
  gt as default
};
