import a from "./Localization.js";
import { loadTranslations as l, formatLocale as c, parseLocale as n } from "./utils.js";
import { FALLBACK_LOCALE as p, EXCLUDE_PROPS as u } from "./constants/localization.js";
import { struct as f } from "../../utils/struct/main.js";
import { isFunction as s } from "../../utils/value/is.js";
function b() {
  let o = this.locale, r = o, t = [...this.supportedLocales];
  return f({
    load: {
      value: (e, i) => l(o, e, i)
    },
    locale: {
      get: () => o,
      set: (e) => {
        r = e, o = c(e) || n(e, t) || p;
      }
    },
    supportedLocales: {
      get: () => t,
      set(e) {
        t = e, this.locale = r;
      }
    }
  });
}
function O() {
  var r;
  const o = {};
  for (const [t, e] of Object.entries(Object.getOwnPropertyDescriptors(a.prototype)))
    u.includes(t) || (s(e.get) ? o[t] = {
      get: e.get.bind(this),
      ...t === "timezone" && { set: (r = e.set) == null ? void 0 : r.bind(this) }
    } : s(e.value) ? o[t] = { value: e.value.bind(this) } : o[t] = { get: () => this[t] });
  return o;
}
export {
  b as createTranslationsLoader,
  O as getLocalizationProxyDescriptors
};
