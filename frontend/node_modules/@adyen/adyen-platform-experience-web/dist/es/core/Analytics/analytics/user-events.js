var a = Object.defineProperty;
var n = (i, e, s) => e in i ? a(i, e, { enumerable: !0, configurable: !0, writable: !0, value: s }) : i[e] = s;
var t = (i, e, s) => n(i, typeof e != "symbol" ? e + "" : e, s);
class o {
  constructor(e) {
    t(this, "queue", []);
    t(this, "subscriptions", /* @__PURE__ */ new Set());
    /* function to be called when there is at least one subscriber */
    t(this, "doneWaitingForSubscribers");
    /** payload of commmon props sent in every event */
    t(this, "baseTrackingPayload");
    /** properties not set with every event but that may be shared between some events
     * ex. `page` value for `Interacted with form field` events
     */
    t(this, "sharedEventProperties");
    /**
     * Sets params that may be shared between events
     * */
    t(this, "updateSharedEventProperties", (e) => {
      this.sharedEventProperties = { ...this.sharedEventProperties, ...e };
    });
    this.baseTrackingPayload = {
      ...e ? { componentName: e } : {},
      category: "pie",
      subCategory: "pie component",
      userAgent: navigator.userAgent
    }, this.sharedEventProperties = {};
  }
  add(...e) {
    this.queue.push(...e);
  }
  notifySubscribers() {
    if (this.subscriptions.size > 0)
      for (; this.queue.length > 0; ) {
        const e = this.queue.shift();
        this.subscriptions.forEach((s) => s(e));
      }
    else this.doneWaitingForSubscribers === void 0 && new Promise((e) => {
      this.doneWaitingForSubscribers = e;
    }).then(() => {
      this.doneWaitingForSubscribers = void 0, this.notifySubscribers();
    });
  }
  /**
   * Adds an analytics event with all base event properties.
   */
  addEvent(e, s) {
    const r = { ...this.baseTrackingPayload, time: Date.now(), ...s };
    this.add({
      name: e,
      // type: 'add_event',
      properties: r
    }), this.notifySubscribers();
  }
  /**
   * Adds an event with context specific to
   */
  addModifyFilterEvent(e) {
    this.addEvent("Modified filter", {
      ...e,
      subCategory: e.subCategory ?? "Filter"
    });
  }
  /**
   * Tracks an experiment for Mixpanel experiment reporting
   */
  trackExperiment({ name: e, variant: s }) {
    this.add({
      // type: 'add_event',
      name: "$experiment_started",
      properties: {
        ...this.baseTrackingPayload,
        "Experiment name": e,
        "Variant name": s
      }
    });
  }
  /**
   * Starts a timer for an event to measure the time it takes for an event to occur. Time is ended when `addEvent` is executed with the same key
   */
  startEvent(e) {
    this.add({
      // type: 'start_event',
      name: e
    }), this.notifySubscribers();
  }
  /**
   * Subscribes a callback to analytics events. It gets called every time
   * one of the above public methods get called, and the event data is passed back as an array.
   * The callback must have a single argument which is an array of [eventName, eventPayload?].
   * @example
   * ```js
   * const callback = ([eventName, eventPayload]) => console.log(eventName, eventPayload);
   * this.subscribe(callback);
   *
   * const exampleEventPayload = { count: 1, segmentation: { foo: 'bar' } };
   * this.addEvent('exampleEventDidOccur', exampleEventPayload);
   *
   * // `callback` will get called with `['exampleEventDidOccur', exampleEventPayload]`
   * ```
   */
  subscribe(e) {
    var s;
    (s = this.doneWaitingForSubscribers) == null || s.call(this), this.subscriptions.add(e);
  }
  /**
   * Sets params that are sent on every event
   * */
  updateBaseTrackingPayload(e) {
    this.baseTrackingPayload = { ...this.baseTrackingPayload, ...e };
  }
  /**
   * Removes a subscribed callback
   */
  unsubscribe(e) {
    this.subscriptions.has(e) && this.subscriptions.delete(e);
  }
}
const h = (i = !0, e) => i ? new o(e) : {};
export {
  o as UserEvents,
  h as createUserEvents
};
