import { getApiVersion as v, getRequestObject as w, getResponseContentType as R, getResponseDownloadFilename as E, getErrorType as x, isAdyenErrorResponse as C, ErrorTypes as T, handleFetchError as b } from "./utils.js";
import { normalizeLoadingContext as $, normalizeUrl as j } from "../utils.js";
const c = (e, s) => {
  try {
    e == null || e(s);
  } catch {
    throw s;
  }
};
async function q(e) {
  const { errorLevel: s, loadingContext: i = "", path: d } = e, u = e.versionless || !1, f = v(e), h = w(e), m = $(i), g = u ? "" : f, o = new URL(`${m}${g}${j(d)}`);
  return e.params && e.params.forEach((n, r) => {
    const t = decodeURIComponent(n);
    t && o.searchParams.append(r, t);
  }), (async () => {
    let n = !1;
    const r = { level: s };
    try {
      const t = await fetch(o, h);
      if (t.ok) {
        if (t.status === 204)
          return null;
        try {
          switch (R(t)) {
            case "application/json":
              return await t.clone().text() ? await t.json() : null;
            default:
              const p = await t.blob(), y = E(t);
              return { blob: p, filename: y };
          }
        } catch (l) {
          throw n = !0, l;
        }
      }
      r.type = x(t.status);
      const a = await t.json();
      r.message = e.errorMessage || `Service at ${o} not available`, r.errorCode = (a == null ? void 0 : a.status) == null ? void 0 : String(a.status), r.requestId = a == null ? void 0 : a.requestId, C(a) && (r.message = a.detail, r.errorCode = a.errorCode, r.status = a.status, r.invalidFields = a.invalidFields), c(e.errorHandler, r);
    } catch (t) {
      if (n)
        throw c(e.errorHandler, t), t;
      r.type || (r.type = T.NETWORK_ERROR), c(e.errorHandler, t), r.message = e.errorMessage || `Call to ${o} failed. Error: ${t}`;
    }
    b(r);
  })();
}
function L(e) {
  return q({ ...e, method: "GET" });
}
export {
  q as http,
  L as httpGet
};
