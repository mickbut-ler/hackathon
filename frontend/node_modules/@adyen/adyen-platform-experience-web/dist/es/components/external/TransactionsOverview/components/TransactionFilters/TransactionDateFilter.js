import { jsx as K } from "../../../../../external/preact/jsx-runtime/dist/jsxRuntime.module.js";
import { TRANSACTION_DATE_RANGE_CUSTOM as O, TRANSACTION_DATE_RANGE_DEFAULT as x, TRANSACTION_DATE_RANGE_MAX_YEARS as H, TRANSACTION_DATE_RANGES as A } from "../../constants.js";
import { useMemo as m, useRef as j, useState as p, useCallback as C, useEffect as N } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import { DateRangeFilterParam as d } from "../../../../internal/FilterBar/filters/DateFilter/types.js";
import k from "../../../../internal/FilterBar/filters/DateFilter/DateFilterCore.js";
import U from "../../../../../hooks/useAnalytics/useFilterAnalyticsEvent.js";
import V from "../../../../../core/Context/useCoreContext.js";
import W from "../../../../internal/Calendar/calendar/timerange/factory.js";
import { unreachable as q } from "../../../../../utils/common.js";
import { EMPTY_OBJECT as z } from "../../../../../utils/value/constants.js";
import { TIME_RANGE_SELECTION_PRESET_OPTION_KEYS as a } from "../../../../internal/DatePicker/components/TimeRangeSelector/useTimeRangeSelection.js";
const B = (e) => {
  switch (e) {
    case "common.filters.types.date.rangeSelect.options.custom":
      return "Custom";
    case a.LAST_7_DAYS:
      return "Last 7 days";
    case a.LAST_30_DAYS:
      return "Last 30 days";
    case a.THIS_WEEK:
      return "This week";
    case a.LAST_WEEK:
      return "Last week";
    case a.THIS_MONTH:
      return "This month";
    case a.LAST_MONTH:
      return "Last month";
    case a.YEAR_TO_DATE:
      return "Year to date";
    default:
      return q(e);
  }
}, re = ({ createdDate: e, eventCategory: w, eventSubCategory: I, setCreatedDate: y, timezone: F }) => {
  const { i18n: o } = V(), S = m(() => o.get("common.filters.types.date.label"), [o]), i = m(() => o.get(O), [o]), u = m(() => o.get(x), [o]), _ = j(e), [T, g] = p(u), [R, E] = p(!1), { from: L, to: b, since: h, until: Y, now: M } = m(() => {
    const s = Date.now(), t = new Date(e.from), c = new Date(e.to), n = new Date(s), f = new Date(s);
    return n.setFullYear(n.getFullYear() - H), {
      from: t.toISOString(),
      to: c.toISOString(),
      since: n.toISOString(),
      until: f.toISOString(),
      now: s
    };
  }, [e]), { logEvent: r } = U({ category: w, subCategory: I, label: "Date filter" }), P = C(
    (s = z) => {
      const t = s.selectedPresetOption || u;
      if (t !== T || t === i) {
        let c = O, n;
        if (t === i) {
          const l = s[d.FROM], D = s[d.TO];
          n = W({
            from: l ? new Date(l).getTime() : e.from,
            to: D ? new Date(D).getTime() : e.to
          })();
        } else
          [c, n] = Object.entries(A).find(([l]) => o.get(l) === t);
        const f = t === i ? String([n.from, n.to]) : B(c);
        g(t), y(_.current = n), r == null || r("update", f);
      }
    },
    [o, e, i, u, T, r]
  ), G = C(() => E(!0), []);
  return N(() => {
    R && (E(!1), _.current !== e && (r == null || r("reset")));
  }, [R, e, r]), N(() => {
    var t;
    const s = (t = Object.entries(A).find(([c, n]) => n === e)) == null ? void 0 : t[0];
    g(s ? o.get(s) : i);
  }, [e, i, o]), /* @__PURE__ */ K(
    k,
    {
      name: "createdAt",
      now: M,
      label: S,
      "aria-label": S,
      sinceDate: h,
      untilDate: Y,
      from: L,
      to: b,
      onChange: P,
      onResetAction: G,
      selectedPresetOption: T,
      timeRangePresetOptions: A,
      timezone: F,
      showTimezoneInfo: !0
    }
  );
};
export {
  re as default
};
