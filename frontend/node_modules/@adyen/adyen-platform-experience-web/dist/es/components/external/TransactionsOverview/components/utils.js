import { INITIAL_FILTERS as s } from "../constants.js";
import { EMPTY_OBJECT as o } from "../../../../utils/value/constants.js";
const i = Object.keys(s), u = Object.freeze({
  klarna: "Klarna",
  paypal: "PayPal",
  klarna_paynow: "Klarna Pay Now"
}), p = (e, a) => {
  const { lastFourDigits: t, description: n, type: r } = e ?? o;
  return t ? a === "detail" ? `•••• •••• •••• ${t}` : t : n || u[r] || r;
}, l = (e) => {
  var a;
  return {
    balanceAccountId: (a = e.balanceAccount) == null ? void 0 : a.id,
    // using null assertion to ensure correct type inference
    categories: e.categories,
    createdSince: new Date(e.createdDate.from).toISOString(),
    createdUntil: new Date(e.createdDate.to).toISOString(),
    currencies: e.currencies,
    paymentPspReference: e.paymentPspReference,
    statuses: e.statuses
  };
}, S = (e) => {
  const { balanceAccountId: a, categories: t, currencies: n, statuses: r, ...c } = l(e);
  return {
    ...c,
    balanceAccountId: a || void 0,
    categories: String(t) || void 0,
    currencies: String(n) || void 0,
    statuses: String(r) || void 0
  };
}, m = (e, a) => i.some((t) => {
  const n = e[t], r = a[t];
  switch (t) {
    case "categories":
    case "currencies":
    case "statuses":
      return String(n) !== String(r);
    default:
      return n !== r;
  }
});
export {
  m as compareTransactionsFilters,
  S as getTransactionsFilterParams,
  l as getTransactionsFilterQueryParams,
  p as parsePaymentMethodType
};
