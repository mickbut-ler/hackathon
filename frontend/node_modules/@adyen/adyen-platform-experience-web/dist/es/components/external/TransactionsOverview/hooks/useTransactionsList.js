import { DEFAULT_PAGE_LIMIT as q, LIMIT_OPTIONS as x } from "../../../internal/Pagination/constants.js";
import { TRANSACTION_FIELDS_REMAPS as k, TRANSACTION_FIELDS as G } from "../components/TransactionsTable/TransactionsTable.js";
import { getTransactionsFilterParams as Q, getTransactionsFilterQueryParams as U } from "../components/utils.js";
import { useCustomColumnsData as j } from "../../../../hooks/useCustomColumnsData.js";
import { useMemo as m, useRef as F, useCallback as T, useEffect as w } from "../../../../external/preact/hooks/dist/hooks.module.js";
import { normalizeCustomFields as B } from "../../../utils/customData/normalizeCustomFields.js";
import { hasCustomField as H } from "../../../utils/customData/hasCustomField.js";
import { mergeRecords as J } from "../../../utils/customData/mergeRecords.js";
import K from "../../../internal/Pagination/hooks/useCursorPaginatedRecords.js";
import { useConfigContext as V } from "../../../../core/ConfigContext/context.js";
import { isFunction as g } from "../../../../utils/value/is.js";
const cr = ({
  allowLimitSelection: P = !0,
  preferredLimit: R = q,
  dataCustomization: t,
  fetchEnabled: C,
  filters: e,
  onFiltersChanged: l
}) => {
  const { getTransactions: o } = V().endpoints, r = m(() => Q(e), [e]), u = F(r).current, d = F(u), A = g(o) && C, I = T(
    async (n, a) => {
      const c = {
        ...n,
        ...U(e),
        sortDirection: "desc"
      };
      return o({ signal: a }, { query: c });
    },
    [e, o]
  ), {
    canResetFilters: W,
    error: h,
    fetching: D,
    filters: X,
    limit: L,
    limitOptions: S,
    records: _,
    resetFilters: Y,
    updateFilters: s,
    updateLimit: E,
    ...O
  } = K({
    dataField: "data",
    fetchRecords: I,
    enabled: A,
    filterParams: u,
    initialFiltersSameAsDefault: !0,
    onFiltersChanged: g(l) ? l : void 0,
    preferredLimitOptions: P ? x : void 0,
    preferredLimit: R
  }), N = T(
    ({ records: n, retrievedData: a }) => J(n, a, (c, b) => c.id === b.id),
    []
  ), { fields: f, onDataRetrieve: y } = (t == null ? void 0 : t.list) ?? {}, i = m(() => B(f, k), [f]), p = m(() => H(i, G), [i]), { customRecords: M, loadingCustomRecords: v } = j({ hasCustomColumn: p, mergeCustomData: N, onDataRetrieve: y, records: _ });
  return w(() => {
    d.current !== r && (d.current = r, s == null || s(r));
  }, [r, s]), {
    ...O,
    error: h,
    fields: i,
    fetching: D || v,
    records: M,
    hasCustomColumn: p,
    limit: L,
    limitOptions: S,
    updateLimit: E
  };
};
export {
  cr as default
};
