import { useMemo as R } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import { RefundMode as l, RefundedState as N } from "../../types.js";
import { REFUND_STATUSES as U } from "../../constants.js";
import { boolOrFalse as _ } from "../../../../../utils/value/bool.js";
import { isFunction as h } from "../../../../../utils/value/is.js";
import { useConfigContext as D } from "../../../../../core/ConfigContext/context.js";
const C = (u) => {
  var E;
  const e = u == null ? void 0 : u.refundDetails, c = (e == null ? void 0 : e.refundMode) ?? l.FULL_AMOUNT, F = _(e == null ? void 0 : e.refundLocked), L = c !== l.NON_REFUNDABLE, n = R(() => {
    var f;
    return u ? Math.max(0, ((f = e == null ? void 0 : e.refundableAmount) == null ? void 0 : f.value) ?? 0) : 0;
  }, [e, u]), M = h(D().endpoints.initiateRefund), p = M && L && n > 0, I = ((E = e == null ? void 0 : e.refundableAmount) == null ? void 0 : E.currency) ?? (u == null ? void 0 : u.netAmount.currency) ?? "", T = !p || F, d = R(() => {
    let f = -1;
    return ((e == null ? void 0 : e.refundStatuses) ?? []).reduceRight(
      (o, { amount: t, status: r }, s) => {
        if (t.value !== 0 && U.includes(r)) {
          const m = r !== "failed", A = s > f;
          if (m && A && (f = s), m || A) {
            const S = (o[r] ?? []).concat(Math.abs(t.value));
            return { ...o, [r]: S };
          }
        }
        return o;
      },
      {}
    );
  }, [e == null ? void 0 : e.refundStatuses]), { fullRefundFailed: a, fullRefundInProgress: b, refundedAmount: i } = R(() => {
    let f = !1, o = !1;
    const t = (d.completed ?? []).reduce((m, A) => m + A, 0), r = d.in_progress ?? [], s = d.failed ?? [];
    return t === 0 && (f = r.length === 0 && s.slice(-1)[0] === n, o = r.length === 1 && r[0] === n), { fullRefundFailed: f, fullRefundInProgress: o, refundedAmount: t };
  }, [n, d]), g = R(() => {
    if (i > 0)
      switch (c) {
        case l.NON_REFUNDABLE:
          if (n === 0) return N.FULL;
          break;
        case l.PARTIAL_AMOUNT:
        case l.PARTIAL_LINE_ITEMS:
          if (n > 0) return N.PARTIAL;
          break;
      }
    return N.INDETERMINATE;
  }, [n, i, c]);
  return {
    fullRefundFailed: a,
    // whether the last (and only) refund that failed is the full refundable amount
    fullRefundInProgress: b,
    // whether the only refund in progress is the full refundable amount
    refundableAmount: n,
    // the maximum amount still available for refund
    refundable: L,
    // whether the refund mode of the payment allows for refund
    refundAvailable: p,
    // whether a refund can be initiated for the payment
    refundAuthorization: M,
    // whether the authenticated user has sufficient permission to initiate refunds
    refundCurrency: I,
    // the payment currency for any initiated refund
    refundDisabled: T,
    // whether refund action for the payment is disabled (refund view should be prevented)
    refundAmounts: d,
    // lookup of refund amounts by refund statuses
    refundedAmount: i,
    // the total amount already refunded
    refundedState: g,
    // whether the payment is yet to be, partially or fully refunded
    refundLocked: F,
    // whether refund action for the payment is temporarily locked
    refundMode: c
    // the refund mode of the payment
  };
};
export {
  C as default,
  C as useRefundMetadata
};
