import { useFetch as h } from "../../../../hooks/useFetch.js";
import { useRef as F, useCallback as k, useMemo as q } from "../../../../external/preact/hooks/dist/hooks.module.js";
import { getTransactionsFilterQueryParams as x } from "../components/utils.js";
import { createAbortable as L } from "../../../../primitives/async/abortable/main.js";
import { useConfigContext as O } from "../../../../core/ConfigContext/context.js";
import { isFunction as R } from "../../../../utils/value/is.js";
import { EMPTY_ARRAY as w } from "../../../../utils/value/constants.js";
const C = {
  expenses: 0,
  incomings: 0,
  total: 0,
  breakdown: {
    expenses: [],
    incomings: []
  }
}, G = ({ currencies: l, fetchEnabled: m, filters: u, loadingBalances: f }) => {
  const { getTransactionTotals: s } = O().endpoints, p = F(L()).current, n = R(s), e = n && m, T = k(async () => {
    if (e) {
      const { signal: r } = p.refresh(!0);
      try {
        const { balanceAccountId: o, createdSince: i, createdUntil: t } = x(u), a = await s({ signal: r }, { query: { balanceAccountId: o, createdSince: i, createdUntil: t } });
        if (!r.aborted) return a == null ? void 0 : a.data;
      } catch (o) {
        if (!r.aborted) throw o;
      }
    }
  }, [p, e, u, s]), { data: c, error: d, isFetching: b } = h({
    fetchOptions: { enabled: e },
    queryFn: T
  }), { totals: y, totalsLookup: A } = q(() => {
    const r = Array.isArray(c) ? c : w, o = l.map((t) => r.find(({ currency: a }) => a === t) ?? { ...C, currency: t }), i = Object.fromEntries(o.map((t) => [t.currency, t]));
    return { totals: o, totalsLookup: i };
  }, [c, l]);
  return {
    totals: y,
    totalsLookup: A,
    error: d,
    isAvailable: n,
    isWaiting: b || f || n && !m
  };
};
export {
  G as default
};
