var Ct = Object.defineProperty;
var ot = (m) => {
  throw TypeError(m);
};
var Rt = (m, s, i) => s in m ? Ct(m, s, { enumerable: !0, configurable: !0, writable: !0, value: i }) : m[s] = i;
var Z = (m, s, i) => Rt(m, typeof s != "symbol" ? s + "" : s, i), et = (m, s, i) => s.has(m) || ot("Cannot " + i);
var t = (m, s, i) => (et(m, s, "read from private field"), i ? i.call(m) : s.get(m)), h = (m, s, i) => s.has(m) ? ot("Cannot add the same private member more than once") : s instanceof WeakSet ? s.add(m) : s.set(m, i), e = (m, s, i, n) => (et(m, s, "write to private field"), n ? n.call(m, i) : s.set(m, i), i), a = (m, s, i) => (et(m, s, "access private method"), i);
var M = (m, s, i, n) => ({
  set _(f) {
    e(m, s, f, i);
  },
  get _() {
    return t(m, s, n);
  }
});
import { resolveTimeFrameBlockSize as yt, downsizeTimeFrame as ft } from "../common/utils.js";
import At, { UNBOUNDED_SLICE as rt } from "../../timeslice/index.js";
import { computeTimestampOffset as Dt } from "../../utils.js";
import { FIRST_WEEK_DAYS as _t, DAY_MS as ct, SHIFT_FRAME as ht, SHIFT_PERIOD as bt, SHIFT_BLOCK as xt, CURSOR_NEXT_BLOCK as Lt, CURSOR_PREV_BLOCK as Ut, CURSOR_LINE_END as Nt, CURSOR_LINE_START as wt, CURSOR_BLOCK_END as zt, CURSOR_BLOCK_START as Wt, CURSOR_DOWNWARD as Mt, CURSOR_UPWARD as Ht, CURSOR_FORWARD as Kt, CURSOR_BACKWARD as vt, SELECTION_COLLAPSE as Yt, SELECTION_NEAREST as lt, SELECTION_FARTHEST as ut, SELECTION_TO as dt, SELECTION_FROM as gt } from "../../constants.js";
import Vt from "../common/flags.js";
import { BASE_LOCALE as Xt } from "../../../../../../core/Localization/datetime/restamper/constants.js";
import { today as pt } from "../../../../../../primitives/time/today/main.js";
import { createIndexed as $ } from "../../../../../../primitives/auxiliary/indexed/main.js";
import { isUndefined as tt, isNullish as A, isBoolean as Ot, isFunction as jt } from "../../../../../../utils/value/is.js";
import { isInfinity as nt, clamp as at, mid as qt, isBitSafeInteger as Ft, mod as Gt } from "../../../../../../utils/value/number.js";
import { enumerable as I } from "../../../../../../utils/struct/property.js";
import { struct as Jt } from "../../../../../../utils/struct/main.js";
var L, p, K, v, Y, V, k, F, B, U, N, w, D, S, X, u, c, l, z, E, _, W, T, j, q, R, C, G, J, st, it, r, Tt, It, b, Bt, O, H, mt;
const x = class x {
  constructor() {
    h(this, r);
    h(this, p, 0);
    h(this, K);
    h(this, v);
    h(this, Y, -1);
    h(this, V, -1);
    h(this, k);
    h(this, F);
    h(this, B);
    h(this, U, !1);
    h(this, N);
    h(this, w, 0);
    h(this, D, []);
    h(this, S, t(x, L));
    h(this, X, 12);
    h(this, u);
    h(this, c);
    h(this, l, 1);
    h(this, z);
    h(this, E);
    h(this, _);
    h(this, W, pt());
    h(this, T);
    h(this, j, -1 / 0);
    h(this, q, 1 / 0);
    h(this, R, -1 / 0);
    h(this, C, 1 / 0);
    h(this, G, 1 / 0);
    h(this, J, 0);
    Z(this, "daysInWeek", 0);
    Z(this, "origin");
    Z(this, "originTimestamp");
    h(this, st, $(() => this.daysInWeek, this.getDayOfWeekAtIndex.bind(this)));
    h(this, it, $(() => t(this, l), a(this, r, Bt).bind(this)));
  }
  get fromTimestamp() {
    return t(this, j);
  }
  get toTimestamp() {
    return t(this, q);
  }
  get numberOfBlocks() {
    return t(this, G);
  }
  get blankSelection() {
    return t(this, u) === t(this, c) && tt(t(this, c));
  }
  get cursor() {
    return t(this, k) ?? -1;
  }
  get daysOfWeek() {
    return t(this, st);
  }
  get dynamicBlockHeight() {
    return t(this, U);
  }
  set dynamicBlockHeight(s) {
    A(s) ? e(this, U, !!s) : Ot(s) && e(this, U, s);
  }
  set effect(s) {
    A(s) ? e(this, N, void 0) : jt(s) && e(this, N, s);
  }
  get firstWeekDay() {
    return t(this, w);
  }
  set firstWeekDay(s) {
    if (A(s))
      this.firstWeekDay = 0;
    else if (!_t.includes(s) || t(this, w) === e(this, w, s)) return;
  }
  get frameBlocks() {
    return t(this, it);
  }
  get isAtEnd() {
    return !nt(t(this, C)) && t(this, C) === t(this, l) - 1;
  }
  get isAtStart() {
    return !nt(t(this, R)) && t(this, R) === 0;
  }
  get locale() {
    return t(this, S);
  }
  set locale(s) {
    const i = t(this, S);
    if (A(s))
      e(this, S, t(x, L));
    else if (typeof Intl < "u")
      try {
        e(this, S, new Intl.Locale(s).toString());
      } catch {
        e(this, S, t(x, L));
      }
    t(this, S) !== i && this.refreshFrame(!0);
  }
  get selectionStart() {
    return t(this, u);
  }
  get selectionEnd() {
    return t(this, c);
  }
  get size() {
    return t(this, l);
  }
  set size(s) {
    const i = Math.min(!A(s) && yt(s) || 1, t(this, X));
    t(this, l) !== e(this, l, i) && (a(this, r, mt).call(this), this.refreshFrame());
  }
  get timeslice() {
    return t(this, E);
  }
  set timeslice(s) {
    if (s === t(this, z) || A(s) && t(this, z) === rt) return;
    const { from: i, to: n, timezone: f } = e(this, z, s ?? rt);
    e(this, E, At(i, n)), this.timezone = f;
  }
  get timezone() {
    return t(this, _);
  }
  set timezone(s) {
    t(this, E).timezone = s, e(this, _, t(this, E).timezone), e(this, W, pt(t(this, _))), t(this, T) && (t(this, T).call(this), e(this, T, t(this, W).subscribe(this.refreshFrame.bind(this, !0)))), a(this, r, Tt).call(this);
  }
  set trackCurrentDay(s) {
    Ot(s) ? s && !t(this, T) ? e(this, T, t(this, W).subscribe(this.refreshFrame.bind(this, !0))) : !s && t(this, T) && (t(this, T).call(this), e(this, T, void 0)) : A(s) && (this.trackCurrentDay = !1);
  }
  get units() {
    return t(this, J);
  }
  initialize() {
    this.timeslice = rt;
  }
  refreshFrame(s = !1) {
    var i;
    if (t(this, D).length = 0, !(tt(t(this, F)) || s)) {
      const n = this.getFrameBlockAtIndex(t(this, p)), { from: f, to: o } = n.inner, [g] = a(this, r, b).call(this, this.getTimestampAtIndex(f + t(this, F)), !1);
      e(this, F, this.getUnitsOffsetForTimestamp(this.getTimestampAtIndex(f), g));
      const d = f + t(this, F), y = at(f, d, o);
      if (y > d)
        return e(this, F, this.getUnitsForFrameBlockAtIndex(--M(this, p)._) + d - y), t(this, p) >= 0 ? this.refreshFrame() : (e(this, p, t(this, l) - 1), this.shiftFrameByOffset(-1, ht));
      if (y < d)
        return e(this, F, d - y - 1), ++M(this, p)._ < t(this, l) ? this.refreshFrame() : (e(this, p, 0), this.shiftFrameByOffset(1, ht));
      e(this, K, f), e(this, v, o), e(this, B, a(this, r, b).call(this, this.getTimestampAtIndex(d), !1)[0]), e(this, F, this.getCursorBlockOriginTimestampOffset(t(this, B))), e(this, k, f + t(this, F));
      const P = t(this, p) > 0 ? this.getFrameBlockAtIndex(0) : n, Q = t(this, p) < t(this, l) - 1 ? this.getFrameBlockAtIndex(t(this, l) - 1) : n;
      e(this, Y, P.inner.from), e(this, V, Q.inner.to), e(this, J, Q.outer.to + 1);
    }
    this.withCurrentDayTimestamp(), (i = t(this, N)) == null || i.call(this);
  }
  shiftFrameByOffset(s, i) {
    if (s && Ft(s))
      switch (i) {
        case xt:
          return a(this, r, H).call(this, s);
        case bt:
          return a(this, r, H).call(this, s * 12);
        case ht:
        default:
          return a(this, r, H).call(this, s * t(this, l));
      }
  }
  shiftFrameCursor(s) {
    switch (s) {
      case vt:
        return a(this, r, O).call(this, -1);
      case Kt:
        return a(this, r, O).call(this, 1);
      case Ht:
        return a(this, r, O).call(this, -this.rowspan);
      case Mt:
        return a(this, r, O).call(this, this.rowspan);
      case Wt:
        return a(this, r, O).call(this, t(this, K) - t(this, k));
      case zt:
        return a(this, r, O).call(this, t(this, v) - t(this, k));
      case wt:
        return a(this, r, O).call(this, -(t(this, k) % this.rowspan));
      case Nt:
        return a(this, r, O).call(this, this.rowspan - (t(this, k) % this.rowspan + 1));
      case Ut:
        return a(this, r, O).call(this, -this.getUnitsForFrameBlockAtIndex((t(this, p) ?? 0) - 1));
      case Lt:
        return a(this, r, O).call(this, this.getUnitsForFrameBlockAtIndex(t(this, p) ?? 0));
    }
    if (!(s < 0) && s >= t(this, Y) && s <= t(this, V))
      return a(this, r, O).call(this, s - t(this, k));
  }
  shiftFrameToTimestamp(s) {
    e(this, B, this.originTimestamp = a(this, r, b).call(this, s, !1).reduce((i, n) => i + n)), e(this, F, this.getCursorBlockOriginTimestampOffset(t(this, B))), this.reoriginate(), [M(this, R)._, M(this, C)._] = this.getEdgeBlockOffsetsFromOrigin(), a(this, r, mt).call(this), this.refreshFrame(), a(this, r, O).call(this, this.getUnitsOffsetForTimestamp(this.getTimestampAtIndex(t(this, k)), t(this, B)));
  }
  clearSelection() {
    this.blankSelection || (e(this, u, e(this, c, void 0)), this.refreshFrame(!0));
  }
  updateSelection(s, i) {
    const n = t(this, u), f = t(this, c), o = a(this, r, b).call(this, s, !1).reduce((g, d) => g + d);
    switch (i === ut && (o <= n ? i = dt : o >= f && (i = gt)), i) {
      case gt:
        e(this, u, o), e(this, c, Math.max(t(this, u), f ?? o));
        break;
      case dt:
        e(this, c, o), e(this, u, Math.min(n ?? o, t(this, c)));
        break;
      case ut:
      case lt: {
        let g = Math.abs(o - (n ?? o)), d = Math.abs(o - (f ?? o));
        i === lt && ([g, d] = [d, g]), g > d ? e(this, u, o) : e(this, c, o);
        break;
      }
      case Yt:
      default:
        e(this, u, e(this, c, o));
        break;
    }
    (t(this, u) !== n || t(this, c) !== f) && this.refreshFrame(!0);
  }
};
L = new WeakMap(), p = new WeakMap(), K = new WeakMap(), v = new WeakMap(), Y = new WeakMap(), V = new WeakMap(), k = new WeakMap(), F = new WeakMap(), B = new WeakMap(), U = new WeakMap(), N = new WeakMap(), w = new WeakMap(), D = new WeakMap(), S = new WeakMap(), X = new WeakMap(), u = new WeakMap(), c = new WeakMap(), l = new WeakMap(), z = new WeakMap(), E = new WeakMap(), _ = new WeakMap(), W = new WeakMap(), T = new WeakMap(), j = new WeakMap(), q = new WeakMap(), R = new WeakMap(), C = new WeakMap(), G = new WeakMap(), J = new WeakMap(), st = new WeakMap(), it = new WeakMap(), r = new WeakSet(), Tt = function() {
  const { from: s, to: i, span: n, offsets: f } = t(this, E);
  e(this, j, s - f.from), e(this, q, i - f.to), e(this, G, n);
  const o = tt(t(this, u)) ? t(this, u) : Math.max(t(this, u), s), g = tt(t(this, c)) ? t(this, c) : Math.min(t(this, c), i);
  o === t(this, u) || g === t(this, c) ? (e(this, u, o), e(this, c, g)) : e(this, u, e(this, c, void 0)), this.reslice(), e(this, X, ft(12, this.numberOfBlocks)), e(this, l, ft(t(this, l), this.numberOfBlocks)), this.shiftFrameToTimestamp(t(this, B));
}, It = function(s) {
  return at(t(this, R), s || 0, t(this, C) - t(this, l) + 1);
}, b = function(s, i = !0) {
  let n = new Date(s).getTime();
  if (isNaN(n)) return a(this, r, b).call(this, Date.now());
  const { from: f, to: o } = t(this, E), g = at(f, n, o);
  g !== n && i ? (n = qt(f, o), (isNaN(n) || nt(n)) && (n = g)) : n = g;
  const d = Dt(n, t(this, _));
  return [n - d, d];
}, Bt = function(s) {
  if (Ft(s) && s >= 0 && s < t(this, l)) {
    if (!t(this, D)[s]) {
      const i = this.getFrameBlockAtIndex(s);
      if (!i) return;
      const [n, f] = this.getFormattedDataForFrameBlock(i[i.inner.from][0] + ct / 2), o = i.outer.from;
      t(this, D)[s] = $(
        {
          datetime: I(f),
          label: I(n),
          length: I(Math.ceil(i.outer.units / this.rowspan)),
          month: I(i.month),
          year: I(i.year)
        },
        (g) => {
          const d = g * this.rowspan;
          return $(this.rowspan, (y) => {
            const [P, Q] = i[y + d], [St, Et] = this.getFormattedDataForBlockCell(P + ct / 2);
            return Jt({
              datetime: I(Et),
              flags: I(Vt(Q)),
              index: I(o + y + d),
              label: I(St),
              timestamp: I(P)
            });
          });
        }
      );
    }
    return t(this, D)[s];
  }
}, O = function(s) {
  s !== 0 && (e(this, F, t(this, F) + s), this.refreshFrame());
}, H = function(s) {
  const i = a(this, r, It).call(this, s);
  i && (this.shiftOrigin(i), e(this, R, t(this, R) - i), e(this, C, t(this, C) - i), e(this, p, Gt(t(this, p) - i, t(this, l))), this.refreshFrame());
}, mt = function() {
  const s = t(this, l) - 1, i = Math.min(s - this.origin % t(this, l), t(this, C)) - s;
  i && a(this, r, H).call(this, i);
}, h(x, L, Xt);
let kt = x;
export {
  kt as default
};
