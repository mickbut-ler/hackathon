import { useRef as f, useMemo as m } from "../../../../external/preact/hooks/dist/hooks.module.js";
import { DEFAULT_PAGE_LIMIT as l } from "../constants.js";
import { getClampedPageLimit as a } from "../utils.js";
import { mid as d } from "../../../../utils/value/number.js";
import { isNumber as p } from "../../../../utils/value/is.js";
const h = (r, o) => {
  const n = r.length - 1;
  if (n < 0) return o;
  if (o <= r[0]) return r[0];
  if (o >= r[n]) return r[n];
  let i = 0, c = 0, s = n;
  for (; ; ) {
    const e = r[i = d(c, s)];
    if (c > s || o === e) return e;
    o > e ? c = i + 1 : s = i - 1;
  }
}, q = ({
  preferredLimit: r = l,
  preferredLimitOptions: o
}) => {
  const n = f(), i = f(), c = m(() => {
    try {
      const e = /* @__PURE__ */ new Set();
      for (const t of o) {
        const u = a(t);
        u > 0 && e.add(u);
      }
      return Object.freeze([...e].sort((t, u) => t - u));
    } catch {
    }
  }, [o]);
  return { limit: m(() => {
    let e = a(r) || l;
    t: try {
      const t = new Set(n.current = c);
      if (t.size === 0) {
        n.current = void 0;
        break t;
      }
      if (i.current !== e)
        e: {
          if (t.size === t.add(e).size)
            break e;
          if (t.delete(e), t.size === t.add(i.current).size) {
            if (p(i.current)) {
              e = i.current;
              break e;
            }
          } else t.delete(i.current);
          e = h(n.current, e);
        }
    } catch {
    }
    return i.current = e;
  }, [c, r]), limitOptions: c };
};
export {
  q as default,
  h as getNearestFromSortedUniqueNums
};
