import { createRangeTimestampsConfigRestampingContext as W, parseRangeTimestamp as i, isRangeTimestampsConfigWithoutOffsets as Y, getRangeTimestampsConfigParameterUnwrapper as b, isRangeTimestampsConfigWithFromOffsets as E } from "./utils.js";
import H from "../../../../../core/Localization/datetime/restamper/restamper.js";
import { EMPTY_OBJECT as u } from "../../../../../utils/value/constants.js";
import { asPlainObject as d, struct as C } from "../../../../../utils/struct/main.js";
import { getter as c } from "../../../../../utils/struct/property.js";
const U = (R = u, D = u) => {
  const s = d(R), h = d(D);
  return () => {
    const a = H(), l = c(() => o), w = c(() => a.tz.current), f = C({
      now: l,
      timezone: w,
      ...W(a)
    }), m = b(s, f);
    let { from: n, to: r, now: o } = u;
    const g = (p) => {
      o = i(p ?? Date.now()) ?? o;
      t: {
        if (Y(s)) {
          n = i(m(s.from)) ?? o, r = i(m(s.to)) ?? o;
          break t;
        }
        let t, e, T;
        (T = E(s)) ? (t = new Date(n = i(m(s.from)) ?? o), e = 1) : (t = new Date(r = i(m(s.to)) ?? o), e = -1), t = new Date(f.timezoneToSystem(t));
        const [F = 0, O = 0, x = 0, M = 0, S = 0, _ = 0, P = 0] = m(s.offsets);
        t.setFullYear(t.getFullYear() + F * e, t.getMonth() + O * e, t.getDate() + x * e), t.setHours(
          t.getHours() + M * e,
          t.getMinutes() + S * e,
          t.getSeconds() + _ * e,
          t.getMilliseconds() + P * e
        );
        const z = i(f.systemToTimezone(t)) ?? o;
        T ? r = z : n = z;
      }
      n > r && ([n, r] = [r, n]);
    }, y = (p) => {
      const t = a.tz, e = t.current;
      a.tz = p, t.current !== e && g(o);
    };
    return g(), C({
      ...h,
      from: c(() => n),
      now: { ...l, set: g },
      timezone: { ...w, set: y },
      to: c(() => r)
    });
  };
};
export {
  U as default
};
