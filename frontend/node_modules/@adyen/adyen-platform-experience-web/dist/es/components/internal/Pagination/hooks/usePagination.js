import { useRef as p, useCallback as P, useState as T, useMemo as c, useEffect as j } from "../../../../external/preact/hooks/dist/hooks.module.js";
import F from "../../../../hooks/useBooleanState.js";
import H from "../../../../hooks/useMounted.js";
import { getClampedPageLimit as J } from "../utils.js";
import { noop as K } from "../../../../utils/common.js";
import { clamp as L } from "../../../../utils/value/number.js";
const _ = (V, l, z) => {
  const u = p(), s = p(), h = p(), r = p(), i = H(
    P(() => {
      var o;
      (o = u.current) == null || o.abort(), u.current = void 0;
    }, [])
  ), [t, x] = T(r.current), [m, M] = F(!1), e = c(() => J(z), [z]), { getPageCount: v, getPageParams: A, resetPageCount: S, updatePagination: R } = V, n = c(() => l ? (o) => {
    var $;
    if (!(e && Number.isInteger(o))) return;
    const f = v(), a = o < 0 ? o + f + 1 : o;
    a > 0 && (f ? a <= f : a === 1) && (($ = u.current) == null || $.abort(), u.current = new AbortController(), i.current && (((r.current = a) > 1 || f) && x(r.current), (async () => {
      const { signal: b } = u.current, D = { ...A(a, e), limit: e, page: a };
      try {
        const d = await l(D, b);
        if (!d || !i.current) return;
        const { size: y, ...G } = d;
        R(a, e, G), s.current = r.current && Math.max(r.current, s.current || -1 / 0), r.current && r.current === s.current && (h.current = y), r.current === 1 && y > 0 && x(r.current), r.current = void 0, M(!0);
      } catch (d) {
        if (b.aborted) return;
        console.error(d);
      }
    })()));
  } : K, [e, l]), q = P(() => {
    t && n(Math.min(t + 1, v()));
  }, [n, t]), w = P(() => {
    t && n(Math.max(t - 1, 1));
  }, [n, t]), g = c(() => v() || t || void 0, [n, m]), E = c(() => !!(t && g) && t < g, [t, g]), I = c(() => !!t && t > 1, [t]), C = c(
    () => s.current ? (s.current - 1) * e + (h.current || 0) : 0,
    [n, m]
  ), N = c(() => t ? L(0, C - (t - 1) * e, e) : 0, [e, C, t]), B = P(() => {
    S(), s.current = h.current = r.current = void 0, i.current && x(r.current);
  }, [S]);
  return j(() => {
    i.current && m && M(!1);
  }, [m]), { goto: n, hasNext: E, hasPrev: I, limit: e, next: q, page: t, pages: g, pageSize: N, prev: w, resetPagination: B, size: C };
};
export {
  _ as default
};
