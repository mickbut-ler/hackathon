import { useState as S, useRef as b, useMemo as l, useCallback as I } from "../../../../../external/preact/hooks/dist/hooks.module.js";
import C from "../../../../../core/Context/useCoreContext.js";
import k from "../../../Calendar/calendar/timerange/presets/yearToDate.js";
import K from "../../../Calendar/calendar/timerange/presets/lastMonth.js";
import z from "../../../Calendar/calendar/timerange/presets/thisMonth.js";
import F from "../../../Calendar/calendar/timerange/presets/lastWeek.js";
import v from "../../../Calendar/calendar/timerange/presets/thisWeek.js";
import u from "../../../Calendar/calendar/timerange/presets/lastNDays.js";
const n = Object.freeze({
  LAST_7_DAYS: "common.filters.types.date.rangeSelect.options.last7Days",
  LAST_30_DAYS: "common.filters.types.date.rangeSelect.options.last30Days",
  LAST_90_DAYS: "common.filters.types.date.rangeSelect.options.last90Days",
  THIS_WEEK: "common.filters.types.date.rangeSelect.options.thisWeek",
  LAST_WEEK: "common.filters.types.date.rangeSelect.options.lastWeek",
  THIS_MONTH: "common.filters.types.date.rangeSelect.options.thisMonth",
  LAST_MONTH: "common.filters.types.date.rangeSelect.options.lastMonth",
  YEAR_TO_DATE: "common.filters.types.date.rangeSelect.options.yearToDate"
}), U = ({
  exclude: t = []
} = {}) => {
  const o = {
    [n.LAST_7_DAYS]: u(7),
    [n.LAST_30_DAYS]: u(30),
    [n.LAST_90_DAYS]: u(90),
    [n.THIS_WEEK]: v(),
    [n.LAST_WEEK]: F(),
    [n.THIS_MONTH]: z(),
    [n.LAST_MONTH]: K(),
    [n.YEAR_TO_DATE]: k()
  };
  if (!(t != null && t.length)) return Object.freeze(o);
  const i = new Set(t);
  return Object.freeze(
    Object.fromEntries(Object.entries(o).filter(([a]) => !i.has(a)))
  );
}, V = ({
  now: t = Date.now(),
  options: o,
  selectedOption: i,
  timezone: a
}) => {
  const { i18n: p } = C(), [M, A] = S(), [R, g] = S(), [f, T] = S(), E = b(), y = b(), [s, D, c] = l(() => {
    const r = p.get("common.filters.types.date.rangeSelect.options.custom"), e = Object.keys(o), m = Object.freeze(e.map((O) => p.get(O)));
    return [r, (O, N = m) => {
      const Y = N.findIndex((H) => H === O);
      return o[e[Y]];
    }, m];
  }, [p, o]), [d, h] = S(i === s), L = l(() => Object.freeze([...c, s]), [s, c]), W = l(
    () => d ? L : c,
    [d, c, L]
  ), _ = I(
    (r) => {
      const e = D(r, c);
      e && (A(e.from), g(e.to), h(!1), T(r));
    },
    [s, D, f, c]
  ), j = I(() => {
    A(void 0), g(void 0), h(!0), T(s);
  }, [s]);
  return l(() => {
    i === s ? T(s) : _(i);
  }, []), l(() => {
    var r;
    if (E.current !== t || y.current !== a) {
      const e = Object.values(o);
      e.forEach((m) => {
        m.now = t, m.timezone = a;
      }), E.current = t, y.current = (r = e[0]) == null ? void 0 : r.timezone, _(f);
    }
  }, [t, a, o]), {
    customSelection: j,
    from: M,
    onSelection: _,
    options: W,
    selectedOption: f,
    to: R
  };
};
export {
  n as TIME_RANGE_SELECTION_PRESET_OPTION_KEYS,
  V as default,
  U as getTimeRangeSelectionDefaultPresetOptions,
  V as useTimeRangeSelection
};
