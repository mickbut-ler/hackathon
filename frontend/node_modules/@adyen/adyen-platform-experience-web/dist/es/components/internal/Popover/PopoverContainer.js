import { jsx as s } from "../../../external/preact/jsx-runtime/dist/jsxRuntime.module.js";
import { useState as c, useCallback as g, useEffect as v } from "../../../external/preact/hooks/dist/hooks.module.js";
import { PopoverContainerPosition as P } from "./types.js";
import m from "./Popover.js";
/* empty css             */
function S(t) {
  var r;
  const [p, f] = c(performance.now()), [u, d] = c(), i = g(
    (n) => n && t.fixedPositioning ? n.scrollHeight > n.offsetHeight : !1,
    [t.fixedPositioning]
  ), o = (r = t.targetElement.current) == null ? void 0 : r.offsetParent;
  return v(() => {
    if (!i(o)) return;
    const { height: n, y: l } = o.getBoundingClientRect();
    d({
      minY: l,
      maxY: l + n
    });
    let e = null;
    const a = () => {
      e && cancelAnimationFrame(e), e = requestAnimationFrame(() => {
        e = null, f(performance.now());
      });
    };
    return o.addEventListener("scroll", a, { passive: !0 }), () => {
      o.removeEventListener("scroll", a), e && cancelAnimationFrame(e), e = null;
    };
  }, [o, i]), t.fixedPositioning ? (
    // TODO: - Consider using same position from parent element
    //       - Consider adding position prop to components using Popover
    /* @__PURE__ */ s(m, { ...t, position: P.BOTTOM, additionalStyle: u })
  ) : /* @__PURE__ */ s(m, { ...t });
}
export {
  S as default
};
