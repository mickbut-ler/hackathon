var c = (e) => {
  throw TypeError(e);
};
var O = (e, t, s) => t.has(e) || c("Cannot " + s);
var i = (e, t, s) => (O(e, t, "read from private field"), s ? s.call(e) : t.get(e)), n = (e, t, s) => t.has(e) ? c("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, s), f = (e, t, s, T) => (O(e, t, "write to private field"), T ? T.call(e, s) : t.set(e, s), s);
var u = (e, t, s, T) => ({
  set _(l) {
    f(e, t, l, s);
  },
  get _() {
    return i(e, t, T);
  }
});
import { RANGE_FROM as d, RANGE_TO as _ } from "../constants.js";
import { computeTimestampOffset as o, getEdgesDistance as b } from "../utils.js";
var p, h, m, a, r;
class D {
  constructor(...t) {
    n(this, p, 1 / 0);
    n(this, h, 1 / 0);
    n(this, m, -1 / 0);
    n(this, a, 0);
    n(this, r, 0);
    if (t.length >= 3) {
      let s = new Date(t[1]).getTime();
      if (typeof t[2] != "symbol")
        f(this, m, s || i(this, m)), f(this, h, new Date(t[2]).getTime() || i(this, h)), i(this, h) < i(this, m) && ([u(this, h)._, u(this, m)._] = [i(this, m), i(this, h)]), f(this, r, o(i(this, m), t[0])), f(this, a, o(i(this, h), t[0])), f(this, p, b(i(this, m), i(this, h), t[0]) + 1);
      else if (!isNaN(s))
        switch (t[2]) {
          case _:
            f(this, h, s), f(this, a, o(i(this, h), t[0]));
            break;
          case d:
          default:
            f(this, m, s), f(this, r, o(i(this, m), t[0]));
            break;
        }
    }
  }
  get numberOfMonths() {
    return i(this, p);
  }
  get endTimestamp() {
    return i(this, h);
  }
  get endTimestampOffset() {
    return i(this, a);
  }
  get startTimestamp() {
    return i(this, m);
  }
  get startTimestampOffset() {
    return i(this, r);
  }
}
p = new WeakMap(), h = new WeakMap(), m = new WeakMap(), a = new WeakMap(), r = new WeakMap();
export {
  D as default
};
